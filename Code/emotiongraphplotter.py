# -*- coding: utf-8 -*-
"""EmotionGraphPlotter

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rZzm9GYqoqHyoYdC_H5fW7SblfPHbRuF
"""

import glob
import pandas as pd
from google.colab import drive

# 1. Mount your Google Drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import os

# ─── 1.  FILE PATHS ──────────────────────────────────────────────────────────────
csv_human = '/content/drive/MyDrive/twibot22_results/humans_twibot_emotions_combined.csv'          # already-processed file
csv_bot   = '/content/drive/MyDrive/twibot22_results/twibot_bot_roberta_emotions.csv'            # ←--- update this!

datasets = [
    (csv_human, 'Human'),   # label for the legend
    (csv_bot,   'Original bot')
]

# ─── 2.  SHARED SETTINGS ─────────────────────────────────────────────────────────
emotion_cols = ['anger', 'optimism', 'sadness', 'joy']

def load_and_aggregate(path: str) -> pd.DataFrame:
    """Load one CSV → filter from 2009 → 6-month aggregates with 95 % CI."""
    df = pd.read_csv(path, parse_dates=['timestamp'])
    df = df[df['timestamp'] >= '2009-01-01'].set_index('timestamp')

    agg = (
        df[emotion_cols]
          .resample('6MS', origin='epoch')   # bins: 1 Jan / 1 Jul
          .agg(['mean', 'count', 'std'])
          .dropna()
    )

    # add 95 % confidence intervals
    for emo in emotion_cols:
        mu, n, sigma = agg[(emo, 'mean')], agg[(emo, 'count')], agg[(emo, 'std')]
        sem  = sigma / np.sqrt(n)
        agg[(emo, 'ci95')] = 1.96 * sem

    return agg

aggs = {label: load_and_aggregate(path) for path, label in datasets}

# union of all bin edges so both series share the same x-axis
all_idx = sorted(set().union(*(a.index for a in aggs.values())))
for label in aggs:
    aggs[label] = aggs[label].reindex(all_idx)

# ─── 3.  PLOTTING ────────────────────────────────────────────────────────────────
locator   = mdates.MonthLocator(bymonth=[1, 7])   # Jan / Jul ticks
formatter = mdates.DateFormatter('%b %Y')
start, end = min(all_idx), max(all_idx)

for emo in emotion_cols:
    fig, ax = plt.subplots(figsize=(20, 10))

    # one line (±CI) per dataset
    for (path, label) in datasets:
        agg = aggs[label]
        mu   = agg[(emo, 'mean')]
        ci95 = agg[(emo, 'ci95')]

        ax.plot(agg.index, mu, marker='o', linewidth=2, label=f'{label}')
        ax.fill_between(agg.index, mu - ci95, mu + ci95, alpha=0.15)

        # straight trend-line (skip if <2 points)
        valid = mu.dropna()
        if len(valid) > 1:
            x = mdates.date2num(valid.index)
            trend = np.poly1d(np.polyfit(x, valid.values, 1))
            ax.plot(all_idx, trend(mdates.date2num(pd.Index(all_idx))),
                    linestyle='--', linewidth=2)

    # cosmetic tweaks
    ax.set_xlim(start, end)
    ax.set_ylim(0, 1)
    ax.xaxis.set_major_locator(locator)
    ax.xaxis.set_major_formatter(formatter)
    plt.xticks(rotation=45)

    ax.set_title(f'{emo.capitalize()} Over Time (6-Month Averages, 95 % CI)')
    ax.set_xlabel('Date')
    ax.set_ylabel(f'Avg {emo.capitalize()} Score')
    ax.legend()
    plt.tight_layout()
    plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import os

# ─── 1.  FILE PATHS ──────────────────────────────────────────────────────────────
csv_human = '/content/drive/MyDrive/Llama tweets/LlamaTweetEmotions.csv'          # already-processed file
csv_bot   = '/content/drive/MyDrive/twibot22_results/twibot_bot_roberta_emotions.csv'            # ←--- update this!

datasets = [
    (csv_human, 'Llama'),   # label for the legend
    (csv_bot,   'Original bot')
]

# ─── 2.  SHARED SETTINGS ─────────────────────────────────────────────────────────
emotion_cols = ['anger', 'optimism', 'sadness', 'joy']

def load_and_aggregate(path: str) -> pd.DataFrame:
    """Load one CSV → filter from 2009 → 6-month aggregates with 95 % CI."""
    df = pd.read_csv(path, parse_dates=['timestamp'])
    df = df[df['timestamp'] >= '2009-01-01'].set_index('timestamp')

    agg = (
        df[emotion_cols]
          .resample('6MS', origin='epoch')   # bins: 1 Jan / 1 Jul
          .agg(['mean', 'count', 'std'])
          .dropna()
    )

    # add 95 % confidence intervals
    for emo in emotion_cols:
        mu, n, sigma = agg[(emo, 'mean')], agg[(emo, 'count')], agg[(emo, 'std')]
        sem  = sigma / np.sqrt(n)
        agg[(emo, 'ci95')] = 1.96 * sem

    return agg

aggs = {label: load_and_aggregate(path) for path, label in datasets}

# union of all bin edges so both series share the same x-axis
all_idx = sorted(set().union(*(a.index for a in aggs.values())))
for label in aggs:
    aggs[label] = aggs[label].reindex(all_idx)

# ─── 3.  PLOTTING ────────────────────────────────────────────────────────────────
locator   = mdates.MonthLocator(bymonth=[1, 7])   # Jan / Jul ticks
formatter = mdates.DateFormatter('%b %Y')
start, end = min(all_idx), max(all_idx)

for emo in emotion_cols:
    fig, ax = plt.subplots(figsize=(20, 10))

    # one line (±CI) per dataset
    for (path, label) in datasets:
        agg = aggs[label]
        mu   = agg[(emo, 'mean')]
        ci95 = agg[(emo, 'ci95')]

        ax.plot(agg.index, mu, marker='o', linewidth=2, label=f'{label}')
        ax.fill_between(agg.index, mu - ci95, mu + ci95, alpha=0.15)

        # straight trend-line (skip if <2 points)
        valid = mu.dropna()
        if len(valid) > 1:
            x = mdates.date2num(valid.index)
            trend = np.poly1d(np.polyfit(x, valid.values, 1))
            ax.plot(all_idx, trend(mdates.date2num(pd.Index(all_idx))),
                    linestyle='--', linewidth=2)

    # cosmetic tweaks
    ax.set_xlim(start, end)
    ax.set_ylim(0, 1)
    ax.xaxis.set_major_locator(locator)
    ax.xaxis.set_major_formatter(formatter)
    plt.xticks(rotation=45)

    ax.set_title(f'{emo.capitalize()} Over Time (6-Month Averages, 95 % CI)')
    ax.set_xlabel('Date')
    ax.set_ylabel(f'Avg {emo.capitalize()} Score')
    ax.legend()
    plt.tight_layout()
    plt.show()